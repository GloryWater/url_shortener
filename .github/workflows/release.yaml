# Release Workflow - Create versioned releases with changelog
name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.2.3)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  PYTHON_VERSION: "3.12"
  UV_VERSION: "latest"
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ===========================================
  # Validate & Prepare Release
  # ===========================================
  prepare:
    name: Prepare Release
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      prerelease: ${{ steps.get_version.outputs.prerelease }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version from tag or input
        id: get_version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ inputs.version }}"
            PRERELEASE="${{ inputs.prerelease }}"
          else
            VERSION="${{ github.ref_name }}"
            # Remove 'v' prefix if present
            VERSION="${VERSION#v}"
            PRERELEASE="false"
            # Check if version contains pre-release markers
            if [[ "$VERSION" == *"alpha"* ]] || [[ "$VERSION" == *"beta"* ]] || [[ "$VERSION" == *"rc"* ]]; then
              PRERELEASE="true"
            fi
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "prerelease=$PRERELEASE" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          echo "Pre-release: $PRERELEASE"

      - name: Validate version format
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+(\.[0-9]+)?)?$ ]]; then
            echo "âŒ Invalid version format: $VERSION"
            echo "Expected format: X.Y.Z or X.Y.Z-alpha.1"
            exit 1
          fi
          echo "âœ… Version format is valid"

  # ===========================================
  # Run Full CI Suite
  # ===========================================
  ci-suite:
    name: Full CI Suite
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [prepare]

    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v5
        with:
          version: ${{ env.UV_VERSION }}
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: uv sync --extra dev --frozen

      - name: Run linters
        run: |
          uv run ruff check src/ tests/
          uv run ruff format src/ tests/ --check

      - name: Run type checker
        run: uv run mypy src/ --ignore-missing-imports

      - name: Run tests
        env:
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          SECRET_KEY: test-secret-key-for-ci-only
          ENVIRONMENT: testing
        run: uv run pytest --cov=src --cov-fail-under=70 -v

  # ===========================================
  # Build Multi-Platform Images
  # ===========================================
  build-release:
    name: Build Release Artifacts
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [prepare, ci-suite]
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ needs.prepare.outputs.version }}
            type=raw,value=latest

      - name: Build and push multi-platform image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ needs.prepare.outputs.version }}

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.version }}
          format: spdx-json
          output-file: sbom-${{ needs.prepare.outputs.version }}.spdx.json

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ needs.prepare.outputs.version }}
          path: sbom-${{ needs.prepare.outputs.version }}.spdx.json
          retention-days: 90

  # ===========================================
  # Generate Changelog
  # ===========================================
  changelog:
    name: Generate Changelog
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [prepare]
    outputs:
      changelog: ${{ steps.changelog.outputs.changelog }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          PREV_TAG="v$(git describe --tags --abbrev=0 --exclude="v$VERSION" 2>/dev/null || echo "")"

          echo "## ðŸš€ Release v${VERSION}" > changelog.md
          echo "" >> changelog.md

          if [ -n "$PREV_TAG" ] && [ "$PREV_TAG" != "v" ]; then
            echo "### ðŸ“ Changes since $PREV_TAG" >> changelog.md
            echo "" >> changelog.md
            git log --pretty=format:"- %s (%h)" "$PREV_TAG"..HEAD >> changelog.md
          else
            echo "### ðŸ“ Initial Release" >> changelog.md
            echo "" >> changelog.md
            git log --pretty=format:"- %s (%h)" >> changelog.md
          fi

          echo "" >> changelog.md
          echo "" >> changelog.md
          echo "### ðŸ“¦ Docker Images" >> changelog.md
          echo "- \`ghcr.io/${{ github.repository }}:${VERSION}\`" >> changelog.md
          echo "- \`ghcr.io/${{ github.repository }}:latest\`" >> changelog.md

          CHANGELOG=$(cat changelog.md)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload changelog artifact
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: changelog.md
          retention-days: 30

  # ===========================================
  # Create GitHub Release
  # ===========================================
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [prepare, build-release, changelog]
    permissions:
      contents: write
      packages: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download SBOM
        uses: actions/download-artifact@v4
        with:
          name: sbom-${{ needs.prepare.outputs.version }}
          path: ./artifacts

      - name: Download changelog
        uses: actions/download-artifact@v4
        with:
          name: changelog
          path: ./artifacts

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          name: Release v${{ needs.prepare.outputs.version }}
          body_path: ./artifacts/changelog.md
          draft: false
          prerelease: ${{ needs.prepare.outputs.prerelease == 'true' }}
          files: |
            ./artifacts/sbom-${{ needs.prepare.outputs.version }}.spdx.json
          generate_release_notes: true
          make_latest: ${{ needs.prepare.outputs.prerelease == 'false' }}

      - name: Notify release status
        run: |
          echo "## âœ… Release v${{ needs.prepare.outputs.version }} Created!"
          echo ""
          echo "ðŸ“¦ Docker images:"
          echo "- \`ghcr.io/${{ github.repository }}:${{ needs.prepare.outputs.version }}\`"
          echo "- \`ghcr.io/${{ github.repository }}:latest\`"
          echo ""
          echo "ðŸ”— Release: ${{ github.server_url }}/${{ github.repository }}/releases/tag/v${{ needs.prepare.outputs.version }}"

  # ===========================================
  # Deploy to Production (Optional)
  # ===========================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [prepare, release]
    if: needs.prepare.outputs.prerelease == 'false'
    environment:
      name: production
      url: ${{ vars.SERVER_URL || 'http://localhost:8001' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy to production
        env:
          SERVER_USER: ${{ secrets.SERVER_USERNAME || vars.SERVER_USERNAME }}
          SERVER_HOST: ${{ secrets.SERVER_HOST || vars.SERVER_HOST }}
          DEPLOY_PATH: ${{ vars.DEPLOY_PATH || '~/url-shortener' }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          echo "ðŸš€ Deploying v${VERSION} to production..."

          ssh -o StrictHostKeyChecking=no "$SERVER_USER@$SERVER_HOST" << 'ENDSSH'
            set -e

            echo "ðŸ“¦ Pulling release image..."
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION}

            cd $DEPLOY_PATH

            echo "ðŸ›‘ Stopping current services..."
            docker-compose down --remove-orphans || true

            echo "ðŸ”„ Starting release..."
            docker-compose up -d --force-recreate

            echo "â³ Waiting for services..."
            sleep 10

            echo "ðŸ—„ï¸ Running migrations..."
            docker-compose exec -T url-shortener uv run alembic upgrade head || true

            echo "ðŸ—‘ï¸ Cleaning up..."
            docker image prune -af --filter "until=24h" || true

            echo "âœ… Production deployment complete!"
          ENDSSH

      - name: Health check
        run: |
          echo "ðŸ¥ Production health check..."
          ssh -o StrictHostKeyChecking=no "$SERVER_USER@$SERVER_HOST" << 'ENDSSH' || true
            curl -sf http://localhost:8001/health && echo "âœ… Production healthy" || echo "âš ï¸ Checking..."
          ENDSSH
